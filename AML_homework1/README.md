>delete personal information before uploading
>
>delete something not related to the code

## 文件说明
1. 三个py文件分别是：[`pca.py`](./pac.py), [`svd.py`](./svd.py), [`isomap.py`](./isomap.py)，对应题3的三份源代码，直接运行就能出结果`python3 <pythonfile.py>`
    + python 3.6
    + scipy 1.1.0, numpy 1.14.5
    + Windows 和 *nix 都运行过


## 3 [60pts] Dimensionality Reduction
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请实现三种降维方法:PCA，SVD和ISOMAP，并在降维后的空间上用1-NN方法分类。
### (1) [20pts] 请实现PCA完成降维
1. PCA算法：
    ```
    输入：有m条n维数据，m*n的矩阵
    1）将原始数据按列组成n行m列矩阵X(n*m)
    2）将X的每一行（代表一个属性字段）进行零均值化，即减去这一行的均值
    3）求出协方差矩阵C = 1/m * X * XT
    4）求出协方差矩阵的特征值及对应的特征向量
    5）将特征向量按对应特征值大小从上到下按行排列成矩阵，取前k行组成矩阵P
    6）Y=PX即为降维到k维后的数据
    ```
2. 几个细节说明：
    + 协方差矩阵numpy提供了cov函数，但根据公式算出的结果和调用cov算出的结果不一样，结果以公式算的为准。
    + 这里1-NN分类用的是曼哈顿距离
    + 参考了几篇博客，感觉这篇写得比较好: [参考博客](https://www.cnblogs.com/GatsbyNewton/articles/4776683.html)

### (2) [20pts] 请实现SVD完成降维
1. 算法：和pca同理，不同的是pca进行特征分解要求矩阵必须是方阵，所以才会构造出协方差矩阵，是一个方阵，而且这个矩阵对角线上的元素是各个属性的方差，而其它元素是两个属性间的协方差，对角化后就是基变换矩阵（能用于降维）。
2. SVD不要求分解矩阵是方阵，假设A是m\*n的方阵（其中m是样本数，n是维数），A能分解成A=U∑VT，其中V是m\*n, ∑是m\*n, V是n\*n。U和V是酉矩阵，满足矩阵的转置乘矩阵等于单位阵I；∑主对角线上的元素以外全为0，主对角线上的每个元素都称为奇异值。
3. 所以如果想降维就取V的前k列(VT的前k行)，当然∑矩阵应当按照奇异值降序。想降样本数就去U的前k列。
4. `numpy.linalg.svd()`函数能完成矩阵的svd分解，返回的就是U, ∑, VT，并且就是按照奇异值降序。在这里只用到了返回的VT，要注意是转置了。
5. 还有一个要注意的是svd不需要对原始数据转置，其实pca也不用，但是当时看了博客，感觉转置后思路会清晰点，就转置了。

### (3) [20pts] 请实现ISOMAP完成降维
1. ISOMAP算法：
    ```
    输入：样本集D={x1, x2, ..., xm};
         邻近参数k;
         低维空间维数d'.
    过程：
    (1): for i = 1,2,...,m do
    (2):    确定xi的k邻近
    (3):    xi与k邻近点之间的距离设置为欧式距离，与其他点的距离设置为无穷大
    (4): end for
    (5): 调用最短路径算法计算任意两个样本点之间的距离dist(xi, xj);
    (6): 将dist(xi, xj)作为MDS算法的输入;
    (7): return MDS算法的输出
    输出：样本集D在低维空间的投影Z={z1, z2, ..., zm};
    ```
2. MDS算法：
    ```
    输入：给定距离矩阵D=(dij)和降维的r
    过程：
    (1): 计算平方距离矩阵;
    (2): 计算矩阵H和B;
    (3): 对B进行正交分解: B=UΛU';
    (4): 选择r个最大的特征根和相应的特征向量，得到r维空间下的拟合构图X^=Λ^1/2_r·U'_r，其中Λ^_r=diag(λ1, λ2, ..., λr)为B前r个特征根;
    (5): U'_r=[u1, u2, ..., ur]为相应的特征向量组成的矩阵，X^称为X的古典解
    输出: 每一行是样本的r维坐标
    ```
3. 关于细节：
    + 最短路径用了dijkstra算法，但是发现跑splice数据的时候太慢了，之后看到群里有人说scipy里提供了相关的函数，所以最后调库了`scipy.sparse.csgraph.shortest_path()`快多了。dijkstra参考自己本科写的一个c++版本的，所以看起来有些臃肿（毕竟是直接语法翻译）。
    + 连通k：在调用最短路径算法前对图进行了连通性判断（不连通则增加k找到最小的连通k），用的深度优先搜索，而且是非递归的，之前写过一个递归的，但是python最多支持1000层（没考证过，至少在我实验环境中是1000），所以就改成非递归了。详细见`isomap.py`中的`isConnect()`函数。
    + 因为构图的时候，这个图是无向图，所以矩阵表示的话应该是一个对称矩阵（当然我理解的k邻近距离图不应该是无向图），利用这个特性，在赋值和遍历等操作的时候进行了一定的优化，例如一次赋值两个和减少遍历次数等。对splice数据集来说效果比较明显。
    + 同一份代码不同平台跑结果不一样。这一点群里也有同学反映过（包括不同的python版本也可能不一样）。我的`isomap.py`在3个平台上用同样的python3.6跑结果也是不一样的，写在报告里的是Ubuntu 16.04系统的（其他是在macOS High Sierra上跑的）。我认为原因可能是对浮点数的支持不一样，在浮点数的计算中（尤其是距离的计算），精度问题会产生误差。也可能是不同的系统的numpy版本底层优化不一样，numpy强大的数值运算并不是纯python原生的，因此针对不同系统也能自身有不同的优化，这种优化可能带来不同的误差。

### 结果汇总
| DataSet | k = 10 | k = 20 | k = 30 |
| --- | --- | --- | --- |
| PCA sonar | 0.5048543689320388 | 0.4854368932038835 | 0.5339805825242718 |
| PCA splice | 0.5995402298850575 | 0.6308045977011494 | 0.6574712643678161 |
| SVD sonar | 0.6019417475728155 | 0.5728155339805825 | 0.5631067961165048 |
| SVD splice | 0.76 | 0.7425287356321839 | 0.7282758620689656 |
| ISOMAP sonar | 0.5631067961165048 | 0.6019417475728155 | 0.46601941747572817 |
| ISOMAP splice | 0.6349425287356322 | 0.6370114942528735 | 0.6342528735632184 |
